---
title: "Dismantling the bulk: examining neuronal heterogeneity using single-cell techniques"
author: Sara Linker, Apua Paquola, Roger Lasken, and Keegan Korthauer
date: 9/6/2016
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(out.width='750px', out.height='750px', dpi=300,
                      fig.height=7, fig.width=7)
knitr::opts_knit$set(root.dir="~/FestivalWorkshopSC/BrainAtlas")
```

### Welcome to the Festival of Genomics workshop on single-cell analyses

This is an R Markdown document that contains instructions and code for the examples used in todays workshop.  The first few steps will check that you have all the packages and data files necessary to carry out all of the analyses.

# Hour 1: Getting Started
Sara's section
...

### Check that the Brain Atlas data files are present

The following code chunk assumes that Brain Atlas files have been downloaded and placed in the "BrainAtlas" subdirectory of a folder in your home directory entitled "FestivalWorkshopSC".  If you have downloaded these files to another location, either create a new folder and move the files there, or substitute the file path to where they are currently located for "~/FestivalWorkshopSC/BrainAtlas".  If you are using the RStudio Server instance provided by the workshop, change the first line that follows to `setwd("/home/FestivalWorkshopSC/BrainAtlas")`

```{r Check for data files, eval=TRUE, echo=TRUE}
setwd("~/FestivalWorkshopSC/BrainAtlas")
file.exists("cell_metadata.csv")
file.exists("genes_counts.csv")
file.exists("ercc_counts.csv")
file.exists("README.txt")
```

If any of the preceding lines return `FALSE`, double check that you have set the correct working directory and that all download files have been placed in that folder.  If they are missing, you can download the files [here](http://casestudies.brain-map.org/celltax/download_archive).  Note that there will be more files than listed here (including alternate gene count quantifications, and metadata about data-driven cluster memberships as discussed in the paper ["Adult mouse cortical cell taxonomy revealed by single cell transcriptomics"](http://www.nature.com/neuro/journal/v19/n2/full/nn.4216.html)), but these are the ones we will make use of.

### Read the Brain Atlas data files into R

The `read.csv` function in R is useful for reading in .csv (comma-separated value) files.  First, we'll read in the main data file `genes_counts.csv` to a data frame using this function and check its contents.  The extra arguments to this function help to format our object so that we have row and column names, and we use character variables instead of converting to factors.  For more details on these arguments, you can type `help(read.csv)`.  In the resulting `coutns` object, we have genes in rows (24057) and cells in columns (1679).

```{r Read in Counts, eval=TRUE, echo=TRUE}
counts <- read.csv("genes_counts.csv", stringsAsFactors = FALSE, header=TRUE, row.names = 1)
str(counts[,1:20]) # restrict to the first 20 columns (cells) 
```

The `cell_metadata.csv` file contains 1679 rows (one for each cell) and columns containing information such as collection date, sequencing type, total reads, mapping percentage, dissection layer, and major/minor derived cell subtypes. 

```{r Read in Cell Metadata, eval=TRUE, echo=TRUE}
cells <- read.csv("cell_metadata.csv", stringsAsFactors = FALSE, header = TRUE)
str(cells)
```

The 'ercc_counts.csv' file contains 1679 columns (one for each cell) and 93 rows containing the counts for the ERCC spike-in control RNA transcripts (and spike in tdTomato).  The ERCC spike-ins are a standard set of RNA transcripts that are spiked in at known concentrations to each cell (more on this later). We'll remove the tdTomato transcript since this does not serve the same purpose as the ERCC spike-ins.

```{r Read in ERCC, eval=TRUE, echo=TRUE}
ercc <- read.csv("ercc_counts.csv", stringsAsFactors = FALSE, header = TRUE, row.names=1)
str(ercc[,1:20]) # restrict to the first 20 columns (cells)

# remove the tdTomato row
whichTomato <- grep("tdTomato", rownames(ercc))
ercc <- ercc[-whichTomato,]
```

More detailed information about the files downloaded from the Allen Brain Atlas can be found in the `README.txt` file provided.  Here is a peek at the contents of that file.

```{bash Peek at README.txt file, eval=TRUE, echo=TRUE}
# This is a bash command, to be executed at the command line (not within R);
# Alternatively, simply open the README.txt in your favorite text editor to view its contents
head README.txt
```

### Check that the desired R packages have been installed

Once a list of desired R packages is finalized, can check that they are installed with 

```{r Check for desired packages, eval=TRUE, echo=TRUE, results="hide", message=FALSE, warning=FALSE}
require(scde)     #bioconductor
require(monocle)  #bioconductor
require(scran)    #bioconductor
require(scater)   #bioconductor
require(scDD)     #github
require(ggplot2)  #cran
require(devtools) #cran
```

If any of these commands return a message that includes "there is no package called...", then the package is missing and needs to be installed.  Note that packages may be stored in one of several package repositories.  The most popular are Bioconductor, github, and CRAN.  For Bioconductor packages, for example ```edgeR```, this can be done with the following code:

```{r install bioconductor package, echo=TRUE, eval=FALSE, results="hide", message=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("monocle")
```

For CRAN packages, for example ```devtools```, installation can be done with the following code:

```{r install cran packages, echo=TRUE, eval=FALSE}
install.packages(devtools)
``` 

For Github packages, for example ```scDD```, installation can be done with the following code:

```{r install github packages, echo=TRUE, eval = FALSE}
install.packages("devtools")
devtools::install_github("kdkorthauer/scDD")
```

### Visualize major axes of variation in a PCA plot

```{r PCA, eval = TRUE, echo = TRUE}
# extract top 1000 variable genes
gene.var <- apply(counts, 1, function(x) var(log(x[x>0])))
counts.top1000 <- counts[which(rank(-gene.var)<=1000),]

counts.pca <- prcomp(log(counts.top1000+1),
                   center = TRUE,
                   scale. = TRUE) 
summary(counts.pca)$importance[,1:5]
plot(counts.pca, type="l", main="Top 10 PCs")

color_class <- rainbow(length(unique(cells$major_class)))
plot(counts.pca$rotation[,1], counts.pca$rotation[,2], 
      xlab="PC 1", ylab="PC 2", col=color_class[as.numeric(factor(cells$major_class))], pch=20,
      main="PCA plot of cells colored by derived major class")

color_class <- rainbow(length(unique(cells$layer_dissectoin)))
plot(counts.pca$rotation[,1], counts.pca$rotation[,2], 
      xlab="PC 1", ylab="PC 2", col=color_class[as.numeric(factor(cells$layer_dissectoin))], pch=20,
      main="PCA plot of cells colored by Dissection Layer")
```

# Hour 2: Normalization and Quality Control of scRNA-seq
Apua's Section 
...

### Normalization

...

### Quality Control (QC measures)

```{r Detection Rate, eval = TRUE, echo = TRUE}
detectionRate <- apply(counts, 2, function(x) sum(x > 0) / length(x))
hist(detectionRate)
```

...

# Hour 3: Analysis Modules

Keegan's Section
...

### Identify the highly variable genes

In this module, we will identify genes that are highly variable across the entire cell population.  This will give us a subset of genes to focus on that is likely enriched for those that are driving heterogeneity among cellular subtypes.  

For ease in downstream analysis with various R packages we'll make use of today, we'll convert the data.frames that currently (separately) house the counts and cell metadata into a Bioconductor object called an SCESet introduced by the ```scater``` package.  This object is a container that can hold raw and normalized expression values, along with the metadata for both samples and genes, in one place. 

```{r Preprocess, eval = TRUE, echo = TRUE}
library(scater)
library(scran)
rownames(cells) <- cells$long_name

# construct a SCESet that also contains the gene counts, ercc counts, and metadata
all.equal(colnames(counts), colnames(ercc)) # check that the cells are in the same order across the two datasets
counts.all <- rbind(counts, ercc)  # combine the two into one data.frame
eset <- newSCESet(countData = counts.all, phenoData = AnnotatedDataFrame(cells))
isSpike(eset) <- grepl("^ERCC", rownames(eset))  #designate which rows contain spikeins instead of genes (for HVG analysis)

rm(counts); rm(counts.all) # remove counts and counts.all matrices to free up memory (the counts are now stored in the eset object)
```

Now that our SCESet has been created, we'll also perform some basic preprocessing and normalization here to adjust for library size using the pool and deconvolve method in the ```scran``` package, as well as remove genes with very low expression (*** these steps may not be necessary if this was already carried out in Apua's section... Can refer back to the section or move/remove if it is redundant ***).

```{r QC, eval=TRUE, echo=TRUE}
# QC to compare the level of dropout in endogeneous genes to ERCC spike ins in raw data
eset <- calculateQCMetrics(eset, feature_controls=isSpike(eset))
plotQC(eset, type = "exprs-freq-vs-mean")
```

Here we apply a couple of filters to remove genes that are expressed at a uniformly low level across the population, and then apply our chosen normalization procedure.

```{r filter, eval=TRUE, echo=TRUE}

# first, filter out genes that are almost always zero (at least 50 out of 1679 cells must have nonzero expression)
keep <- rowSums(counts(eset) > 0) >= 50
eset <- eset[keep,] 
sum(keep)

# next, filter out genes with very low average nonzero expression across all cells (requres a mean of at least 5 counts across all cells)
keep <- rowMeans(counts(eset)) >= 5
eset <- eset[keep,]
sum(keep)

# normalize counts for library size using the pool & deconvolve method of Lun et al. (2016)
eset <- computeSumFactors(eset, sizes=c(20, 40, 60, 80))
summary(sizeFactors(eset))

# use the size factors calculated above to normalize the counts - these get placed in the 'exprs' slot
eset <- normalize.SCESet(eset)
```

Let's check the correlation of our size factors with the library size.  The strong positive correlation suggests that the size factors calculated by this normalization procedure are primarily adjusting for sequencing depth and overall capture rate. 

```{r plot size factors, eval=TRUE, echo=TRUE}
plot(sizeFactors(eset), colSums(counts(eset))/1e6, log="xy",
    ylab="Library Size (Total Counts in Millions)", xlab="Pooled Size Factor Estimate",
    main="Normalization factor versus library size")
```

Next, we'll perform some calculations to help us identify genes that have high variability.  To do so, we have to take into account the relationship between mean expression level and variance of expression level.  Namely, that what we observe in RNA-seq count data is that genes with higher expression have higher variance (also commonly referred to as 'over-dispersion' in the literature).  Note that for data on the log-scale, the trend is reverse (variance of log-expression decreases for higher mean log-expression genes).  When overdispersion is present, this is also a property of the Negative Binomial distribution, which is often used to model count data from RNA-seq experiments.  

We use the ```trendVar``` function of the ```scran``` package to estimate the relationship between the mean and variance. This function fits a smooth type of curve to capture the overall trend in mean log-expression and variance log-expression, which will serve as an estimate of the baseline technical variability if we assume that the majority of the genes are constantly expressed (i.e. that there is no significant biological variability in the majority of genes).  Once this relationship has been estimated, the ```decomposeVar``` (also in the ```scran``` package) essentially removes the estimated technical variability component from the total variability to calculate the estimated biological variability.  This is what we aim to use to find the highly variable genes.  We also visualize the mean and variance log-expression relationship, along with the estimated technical variabilty fit.  

```{r Indentify Variable Genes, eval=TRUE, echo=TRUE}
var.fit <- trendVar(eset, trend="loess", use.spikes=FALSE, span=0.2)
var.out <- decomposeVar(eset, var.fit)

# plot the mean versus variance of log-expression, along with the technical variance fit
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
    ylab="Variance of log-expression")
o <- order(var.out$mean)
lines(var.out$mean[o], var.out$tech[o], col="dodgerblue", lwd=2)
```

The dip in the beginning of the plot is due to the very low expressed genes having very low variance since they are dominated by zeroes and very low counts. We can see this if we remake the plot but color the points by the proportion of cells with a zero value.


```{r Color by dropout, eval=TRUE, echo=TRUE}
# function to create a gradient of colors
color.gradient <- function(x, colors=c("orange2", "blue"), colsteps=500) {
  return( colorRampPalette(colors) (colsteps) [ findInterval(x, seq(min(x),max(x), length.out=colsteps)) ] )
}
pzero <- apply(counts(eset), 1, function(x) sum(x > 0) / length(x))

# replot with color by proportion of zero
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
    ylab="Variance of log-expression", col=color.gradient(pzero))
colscale <- c(0,0.25,0.5,0.75,1)
legend(11.5,40, title="Proportion cells zero", legend=paste0(1-round(quantile(pzero, colscale),2)),
        col=color.gradient(quantile(pzero, colscale)), pch=16)
```

Recall the assumption we made in estimating the mean-variance relationship above: there is no significant biological variability in the majority of genes.  Is this true in our experiment? How might this assumption be evaluated?

If this assumption is suspect, it is ideal to independently estimate this relationship for so-called 'spike-in' data (where a small number of artifical transcripts have been added at known concentrations such that any variability is assured to be technical).  Fortunately, in this experiment we have ERCC control spike-ins, so we'll repeat the steps above to estimate the mean-variance relationship *only* on the spike-ins. We do this by using the ```use.spikes=TRUE``` option in the ```trendVar``` function.  We also increase the smoothing span a bit since we are using fewer points for estimation.  

```{r Indentify Variable Genes with spikes, eval=TRUE, echo=TRUE}
var.fit.spike <- trendVar(eset, trend="loess", use.spikes=TRUE, span=0.3)
var.out.spike <- decomposeVar(eset, var.fit.spike)

# plot the mean versus variance of log-expression, along with the technical variance fit
plot(var.out.spike$mean, var.out.spike$total, pch=16, cex=0.6, xlab="Mean log-expression", 
    ylab="Variance of log-expression")
o <- order(var.out$mean)
lines(var.out$mean[o], var.out$tech[o], col="dodgerblue", lwd=2)
o <- order(var.out.spike$mean)
lines(var.out.spike$mean[o], var.out.spike$tech[o], col="red", lwd=2)
points(var.fit.spike$mean, var.fit.spike$var, col="red", pch=16)
```

How similar are the two trend estimations?  What does this suggest about the assumption that most genes do not have significant biological variability?

Finally, we extract the top 1000 genes with highest biological variability to use in downstream analyses.  We'll also examine the distributions of the top 25 highly variable genes. Here we will use the estimate of biological variability we obtained by fitting the spike-ins above.  However, note that spike-ins are not always available, they can be challenging to incorporate into the protocol, and won't necessarily capture all of the technical variability depending on where in the protocol they are added.  

```{r Extract Variable Genes, eval=TRUE, echo=TRUE}
# extract and examine the top 1000 genes by biological variance
top.hvg <- order(var.out.spike$bio, decreasing=TRUE)[1:1000]
head(var.out.spike[top.hvg,])

# construct a new eset object that only contains the highly variable genes for downstream analysis
eset.hvg <- eset[top.hvg,]

# plot distribution of the top 25 highly variable genes
top25 <- top.hvg[1:25]
boxplot(t(exprs(eset)[top25,]), las=2, ylab="Normalized log-expression", col="dodgerblue", main="Top 25 Highly Variable Genes")
```

Note that the biological variability estimates provided by \Rcode{decomposeVar} seem to be rather robust to outlier cells, as none of the genes with highest variability seem to be driven by outliers.

Let's also look again at the mean log-expression versus variance log-expression plot we generated above, but this time highlight the locations of top 1000 and top 25 highly variable genes.

```{r Replot HVG, eval=TRUE, echo=TRUE}
# plot the mean versus variance of log-expression, along with the technical variance fit
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
    ylab="Variance of log-expression")
o <- order(var.out.spike$mean)
lines(var.out.spike$mean[o], var.out.spike$tech[o], col="red", lwd=2)
points(var.out$mean[top.hvg], var.out$total[top.hvg], col="darkorange2", cex=0.6, pch=16)
points(var.out$mean[top25], var.out$total[top25], col="red4", cex=0.7, pch=15)
legend(11.5, 40, legend=c("Top 25 HVGs", "Top 1000 HVGs"), pch = c(15, 16), 
       col= c("red4", "darkorange2"), cex=1.1)
```

Finally, we'll create a heatmap plot to visualize how the overall expression of the top 25 HVGs are associated with the major cell classes.

```{r heatmap HVG, eval=TRUE, echo=TRUE}
# extract matrix of hvg expression for plotting
m <- exprs(eset)[top25,]

# plot heatmap 
library(RColorBrewer)
heatmap(m/apply(m,1,max),zlim=c(0,1),labCol=NA, col=brewer.pal(9,"YlOrRd"),
        scale="none",ColSideColors=rainbow(5)[as.numeric(factor(phenoData(eset)$major_class))])
par(lend = 1)           # square line ends for the color legend
legend("topleft", inset=-0.04,
    legend = unique(phenoData(eset)$major_class),
    col = rainbow(5)[as.numeric(as.factor(unique(phenoData(eset)$major_class)))],
    lty= 1, lwd = 5, cex=0.6
)
```

### Identify differentially expressed genes

In this module we will identify differentially expressed genes between neuronal subtypes, as well as between neurons and non-neuronal cell types.  As we have learned in this workshop, though scRNA-seq data shares many characteristics with bulk RNA-seq data, there are major differences which need to be accommodated in order to properly analyze it and fully exploit its advantages (namely the presence of dropouts, or zeroes, and increased heterogeneity from a combination of technical and biological sources).  First we will explore the method ```SCDE``` which compares expression magnitude between groups of cells while adjusting for drop-out and amplification biases in expression magnitude by fitting error models for individual cells.  

After loading the SCDE package, we'll create a vector of indices to indicate which cells we will analyze. In the interest of minimizing computation time during this workshop, we'll only assess the top 1000 highly variable genes for differential expression (these are contained in the ```eset.hvg``` SCESet object).  In addition, some of the SCDE output has been precomputed for you since the method is computationally intensive with a large number of cells (over 1000).  To complete the rest of the module, you'll need to download this results object from GitHub if you are not using one of the server instances (where it will be preloaded) - see the instructions below.

We'll first create a vector that indicates which of the cells have been classified as neurons.  This will be used to subset the SCESet to contain only these cells.  Then we'll reduce this indicator vector to only contain a random sample of 100 cells of each neuron subtype.  We'll also create a ```group``` factor variable that indicates which type of neuron each cell is classified as (inhibitory or exitatory).  Finally, since SCDE requires raw (unnormalized) integer count data as input, we'll extract the raw counts matrix from the subsetted SCESet object and change their class from numeric to integer. 

```{r scde prep, eval = TRUE, echo = TRUE}
library(scde)

# find DE genes between excitatory and inhibitory neuronal subtypes
# first, find which cells are neuron (inhibitory or excitatory)
which.neur <- which(pData(eset.hvg)$major_class %in% c("Inhibitory", "Excitatory"))

# next, construct the group factor labeling for neuron subtype using the index of neuron cells `which.neur' to subset the SCESet object
group <- factor(pData(eset.hvg[,which.neur])$major_class)

# re-create the group factor for the subsampled cell indices
group <- factor(pData(eset.hvg[,which.neur])$major_class)
names(group) <- sampleNames(eset.hvg[,which.neur])

# save counts matrix as integer class; note SCDE requires raw (unnormalized) counts as input. 
cts <- apply(counts(eset.hvg[,which.neur]),2,function(x) {storage.mode(x) <- 'integer'; x}) 
```

With the SCDE inputs prepared, we're ready to fit the SCDE models for these genes. To do so, we first use the ```scde.error.models``` function to fit the cell-specific error models. These error models are then used as input to fit the models for the prior distributions of gene expression magnitude using the ```scde.expression.prior``` function.  Then, both the error models and prior are used as input to the main function ```scde.expression.difference``` function, which performs a test of differential expression for each gene.  The output returns a table that contains the value of the test statistic for each gene, so we'll carry out an additional step to obtain the p-values that correspond to the test statistics.  Note that the columns starting with a 'c' correspond to those that have been corrected for multiple comparisons.  

Note that these model-fitting step can take quite some time, since an individual error model is fit for each cell in the dataset, and pairs of cells are compared to one another in order to estimate the parameters of the fit.  For the purposes of this workshop, the error models object has been precomputed (If you are using the RStudio Server instance, simply load the scde.results.RData file.  If you are using your own machine, you must first download this object from the GitHub page for this vignette - [https://github.com/kdkorthauer/FestivalWorkshopVignettes](https://github.com/kdkorthauer/FestivalWorkshopVignettes) and then save it to your R sessions current working directory).  

```{r scde fit, eval=TRUE, echo=TRUE }
# fit error models using the scde.error.models function (the following steps have already been run in the interest of time - it is computationally intensive)
########## err.mod <- scde.error.models(counts = cts, groups = group, n.cores = 10, min.nonfailed = 30,
########## 						             verbose=1, save.crossfit.plots=FALSE, threshold.segmentation = TRUE,
##########                         min.size.entries = 500, save.model.plots = FALSE, linear.fit=FALSE,
##########                         min.pairs.per.cell=20, max.pairs=10000)

# estimate the prior for gene expression 
########## prior.mod <- scde.expression.prior(models = err.mod, counts = cts, length.out = 400, show.plot = FALSE, max.quantile=0.9999)

# test for differential expression for all genes using the scde.expression.difference function
########## exp.diff <- scde.expression.difference(models = err.mod, counts = cts, prior = prior.mod, groups = group, n.cores = 1)

```

Again, the preceding steps are commented out since they have already been run for you.  Instead, load the results object that contains ```err.mod```, ```prior.mod```, and ```exp.diff```.  We'll add a column to the main results table that displays the p-values associated with the test statistics (both raw and multiplicity-adjusted).

```{r scde DE, eval=TRUE, echo=TRUE}
# load the pre-computed results objects err.mod, prior.mod, and exp.diff (all contained
# in the file "scde.results.RData").  Assumes the file is saved to the current working
# directory
load("scde.results.RData")

# view the top of the main results table
head(exp.diff)

# add a column with p-values and multiplicity-corrected pvalues
exp.diff$Pval <- 2*pnorm(-abs(exp.diff$Z))
exp.diff$cPval <- p.adjust(exp.diff$Pval, method="fdr")
```

We can explore these results to see how many genes are differentially expressed at the 0.05 level after adjusting for mutliple comparisons, and save these results in a .csv file (viewable in Microsoft Excel or a simple text editor). 

```{r scde results, eval=TRUE, echo=TRUE}
# count how many genes have an fdr-adjusted p-value less than 0.05
sum(exp.diff$cPval < 0.05)

# reorder the genes by pvalue
exp.diff <- exp.diff[order(exp.diff$cPval),]
head(exp.diff)

# create a .csv file that lists all the DE genes with fdr-adjusted p-value less than 0.05
write.csv(exp.diff[exp.diff$cPval < 0.05, ], file = "scdeResults_DEgenes.csv", row.names = TRUE, quote = FALSE)
```

To get more insight into the models fit by SCDE, we can use the related ```scde.test.expression.difference``` function to visualize the results for a particular gene. For example, we can view the cell-specific posterior distributions for the two different neuronal subtypes for a DE gene: 

```{r scde plot de, eval=TRUE, echo =TRUE}
# visualize the results for a particular DE gene
scde.test.gene.expression.difference("Gad1", models = err.mod, counts = cts, prior = prior.mod)
```

In contrast, we can look at another gene that is not differentially expressed and see that the cell-specific posterior distributions do not look globally different between excitatory and inhibitory neurons. 

```{r scde plot ee, eval=TRUE, echo=TRUE}
scde.test.gene.expression.difference("Rgs17", models = err.mod, counts = cts, prior = prior.mod)

# reset plot window
dev.off()

# remove the cts matrix to free up memory
rm(cts)
```

Next we'll explore the method ```scDD``` which also compares expression between groups of cells, but aims to detect differences in expression patterns that may be more complex than an overall magnitude change (or mean shift).  Specifically, cells within each group may be captured at different expression states, as may happen if a gene is oscillatory, or if it exhibits stochastic, "bursty" expression dynamics.  ```scDD``` can detect if these types of complex patterns differ across cell groups. 

```{r scdd, eval = TRUE, echo = TRUE}
library(scDD)

# construct object to send to scDD

# find DE genes between excitatory and inhibitory neuronal subtypes

# find DE genes between neuron and non-neuronal

```
*TODO: fill out detailed steps of the scDD analysis modules*...

### Order cells by "Psuedotime" (temporal-spatial variation)

Just like we saw in the Highly Variable Genes module, it can be convenient to store all information about an experiment (measurements *and* metadata) in one R object.  This is a recurring theme in the Bioconductor project, so many R packages on Bioconductor rely on constructs like these.  The benefits are gains in efficiency and reduction of errors in associating metadata objects back to the measurement objects, and often many package developers use objects that are compatible across several methods.  However, with the explosion in methods development for scRNA-seq analysis, we have not yet established a 'standard' object type for storing and analysing scRNA-seq data in R.  The result is that packages developed simulataneously and independently have slightly different formatting requirements.  So long story short, we have to convert our ```SCESet``` object from the ```scater``` package to a similar ```CellDataSet``` object for use with the ```monocle``` package.  Don't worry about the details here.

Our goal in this analysis module is to discover a latent trajectory of variation using ```Monocle``` which may represent spatial organization of the cells.  Since it is recommended to use genes that are believed to be important in determining where cells are located in relation to eachother (the 'ordering'), we use the dataset that only contains the top 2000 highly variable genes that we constructed a previous analysis module.  

```{r Monocle Object, eval = TRUE, echo = TRUE}
library(monocle)
# construct a CellDataSet object with our SCESet object that contains only the top 2000 highly variable genes
cset <- newCellDataSet(cellData = exprs(eset.hvg), phenoData = phenoData(eset.hvg))
class(cset)
```

The ```setOrderingFilter``` function requires that we select which genes to use in the ordering.  Since we have already filtered our ```cset``` dataset to include only the top 2000 highly variable genes, ordered by biological variance, we can subset the top 100 genes to include the top 100 highly variable genes. Before applying Monocle's ordering algorithm, we use the ```reduceDimensions``` function to perform dimension reduction on this set of 2000 genes.  Finally, the ```orderCells``` function carries out the Monocle algorithm.  Note that we need to specify the number of paths here, which represent the number of main cell fates (or states) believed to be present.  Here we choose one, which represents the path along the cortical layers as linear.  Note that this step can take several minutes to complete.

Since we have already demonstrated that major cell type (inhibitory neuron, excitatory neuron, and non-neuronal cell) is a major source of variation, in this module we will examine the trajectories within the major neuronal cell types.  To do so, we create two separate ```CellDataSets``` by subsetting on the major class listed in the phenotypic metadata and carrying out the Monocle algorithm separately on both.  We also subset on the cells that have a major labeled dissection layer other than "All" (lower versus upper in Inhibitory neurons; L1-L6 in Excitatory neurons).

```{r Pseudotime algorithm, eval = TRUE, echo = TRUE}
options(expressions = 500000) # 'under-the-hood' option; need to execute if using OSX or Windows due to a limitation on C stack size

# Run Monocle on subset of Inhibitory neurons
cset.inhibitory <- cset[,phenoData(cset)$major_class=="Inhibitory" & 
                         phenoData(cset)$layer_dissectoin %in% c("lower", "upper")]
cset.inhibitory <- setOrderingFilter(cset.inhibitory, ordering_genes=rownames(cset.inhibitory)[1:100])
cset.inhibitory <- reduceDimension(cset.inhibitory, use_irlba = FALSE) # Reduce dimensionality
cset.inhibitory <- orderCells(cset.inhibitory, num_paths = 1, reverse = FALSE) # Order cells

# Run Monocle on subset of Excitatory neurons
cset.excitatory <- cset[,phenoData(cset)$major_class=="Excitatory" & 
                         phenoData(cset)$layer_dissectoin %in% c("L1", "L2/3", "L4", "L5", "L6", "L6a", "L6b")]
cset.excitatory <- setOrderingFilter(cset.excitatory, ordering_genes=rownames(cset.excitatory)[1:100])
cset.excitatory <- reduceDimension(cset.excitatory, use_irlba = FALSE) # Reduce dimensionality
cset.excitatory <- orderCells(cset.excitatory, num_paths = 1, reverse = FALSE) # Order cells
```

Next we plot the spanning tree to visualize the cell ordering projected on the first two components of variation.  We color the cells in this space by dissection layer see if we have recovered any of the spatial structure of the cortical layers.  We also color the cells by Cre reporter line.  Did we recover any spatial organization in these two subsets?  Does there seem to be variation by Cre reporter?

```{r Pseudotime plotting, eval = TRUE, echo = TRUE}
# plotting by various factors
plot_spanning_tree(cset.inhibitory, color_by="layer_dissectoin") # plot spanning tree
plot_spanning_tree(cset.inhibitory, color_by = "cre")

# Excitatory
plot_spanning_tree(cset.excitatory, color_by="layer_dissectoin") # plot spanning tree
plot_spanning_tree(cset.excitatory, color_by="cre") # plot spanning tree
```

How does the spanning tree change if we allow a different number of paths?  How does the spanning tree change if we include different gene sets?

### R Session information:

```{r sesh, eval=TRUE, echo=TRUE}
sessionInfo()
```

```{r Extract Code Snippets, eval = FALSE, echo = FALSE}
# This snippet just generates a .R file that only contains the code snippets within this document
# Not executed; need to run separately to update the .R file after this file is modified ...
library(knitr)
knitr:::purl("~/Desktop/scRNAseq/FestivalWorkshop2016/FestivalWorkshopVignettes/SingleCellAnalyses.Rmd",  
     output="~/Desktop/scRNAseq/FestivalWorkshop2016/FestivalWorkshopVignettes/SingleCellAnalyses.R")
```
